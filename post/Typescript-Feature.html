<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<link rel="stylesheet" href="/_assets/main.css" />

    <title>TypeScript 语言特性索引  - cyl.moe</title>
  </head>
  <body>
    <div class="main">
      <nav class="navigation">
        <a href="/">cyl.moe</a>
      </nav>
      <article>
        <header>
          <h1 class="article-title">TypeScript 语言特性索引 </h1>
          <div class="article-info">
            <div>
              <span
                >Created At：<time datetime="1564499284734"
                  >2019-07-30 23:08</time
                ></span
              >
              <span
                >Updated At：<time datetime="1633164167592"
                  >2021-10-02 16:42</time
                ></span
              >
            </div>
            
          </div>
        </header>
        <div class="article-content markdown-body"><nav class="table-of-contents"><ul><li><a href="#增强的oop">增强的OOP</a></li><li><a href="#类型系统">类型系统</a></li><li><a href="#其它">其它</a></li></ul></nav><p>该索引对应 TypeScript 版本：4.4</p>
<p>官方 wiki 见<a title="https://www.typescriptlang.org/docs/handbook/release-notes/overview.html" href="https://www.typescriptlang.org/docs/handbook/release-notes/overview.html">https://www.typescriptlang.org/docs/handbook/release-notes/overview.html</a></p>
<h1 id="增强的oop">增强的OOP</h1>
<ul>
<li><a title="http://www.typescriptlang.org/docs/handbook/classes.html#public-private-and-protected-modifiers" href="http://www.typescriptlang.org/docs/handbook/classes.html#public-private-and-protected-modifiers">属性访问权限</a>：<code> public</code> 、<code> private</code>   和  <code> protected</code>（含直接<a title="http://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties" href="http://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties">在构造器参数中设定访问权限并初始化属性的语法糖</a> ）。对构造器方法也适用。其中<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#which-should-i-use" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#which-should-i-use"><code>private</code>与ES标准提供的<code>#</code>语法存在一定区别</a></li>
<li>设置<a title="http://www.typescriptlang.org/docs/handbook/classes.html#readonly-modifier" href="http://www.typescriptlang.org/docs/handbook/classes.html#readonly-modifier">只读属性</a>。包括直接<a title="http://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties" href="http://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties">在构造器参数中设定只读的语法糖</a></li>
<li><a title="http://www.typescriptlang.org/docs/handbook/classes.html#abstract-classes" href="http://www.typescriptlang.org/docs/handbook/classes.html#abstract-classes">抽象类和抽象方法</a>：<code>abstract  </code></li>
<li><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#optional-class-properties" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#optional-class-properties">类的可选属性和方法</a></li>
<li>接口（<code>interface</code>）
<ul>
<li><a title="http://www.typescriptlang.org/docs/handbook/interfaces.html#implementing-an-interface" href="http://www.typescriptlang.org/docs/handbook/interfaces.html#implementing-an-interface">供类实现（<code>implement</code>）</a>。注意：对实现接口的类，<a title="http://www.typescriptlang.org/docs/handbook/interfaces.html#difference-between-the-static-and-instance-sides-of-classes" href="http://www.typescriptlang.org/docs/handbook/interfaces.html#difference-between-the-static-and-instance-sides-of-classes">类型检查将被施加在类的实例上而不是类上</a>。这使得若要约束类的构造器，需要额外定义构造器接口（<a title="https://basarat.gitbooks.io/typescript/content/docs/types/callable.html#newable" href="https://basarat.gitbooks.io/typescript/content/docs/types/callable.html#newable">newable 函数</a> ）</li>
<li>可以<a title="http://www.typescriptlang.org/docs/handbook/interfaces.html#extending-interfaces" href="http://www.typescriptlang.org/docs/handbook/interfaces.html#extending-interfaces">继承其它接口</a>或<a title="http://www.typescriptlang.org/docs/handbook/interfaces.html#interfaces-extending-classes" href="http://www.typescriptlang.org/docs/handbook/interfaces.html#interfaces-extending-classes">继承其它类</a>（使用<code>extends</code>关键字）</li>
</ul>
</li>
</ul>
<h1 id="类型系统">类型系统</h1>
<p>通过尽可能地施加约束， 在编译期发现进行检查，从而尽量避免运行时错误。TS 中所有的类型约束检查均不是靠在编译得到的 JS 代码里加入运行时类型检查代码而进行的</p>
<ul>
<li>
<p><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export">对模块中类型的导入（<code>import type</code>）导出（<code>export type</code>）</a></p>
</li>
<li>
<p>类型系统可用于约束任何值（以变量或字面量的形式均可）。值得说明的包括：</p>
<ul>
<li>函数
<ul>
<li><a title="http://www.typescriptlang.org/docs/handbook/functions.html#typing-the-function" href="http://www.typescriptlang.org/docs/handbook/functions.html#typing-the-function">约束其参数和返回值</a>（包括<a title="http://www.typescriptlang.org/docs/handbook/functions.html#optional-and-default-parameters" href="http://www.typescriptlang.org/docs/handbook/functions.html#optional-and-default-parameters">可选参数、默认参数</a>以及<a title="http://www.typescriptlang.org/docs/handbook/functions.html#rest-parameters" href="http://www.typescriptlang.org/docs/handbook/functions.html#rest-parameters">剩余参数</a>）</li>
<li><a title="https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters" href="https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters">约束其<code>this</code></a></li>
<li>支持<a title="http://www.typescriptlang.org/docs/handbook/functions.html#overloads" href="http://www.typescriptlang.org/docs/handbook/functions.html#overloads">重载声明（overload，不是 override）</a>，但不支持重载实现</li>
</ul>
</li>
<li>类</li>
<li>接口</li>
</ul>
</li>
<li>
<p>可供使用的类型：</p>
<ul>
<li>内置的类型
<ul>
<li><a title="http://www.typescriptlang.org/docs/handbook/basic-types.html#introduction" href="http://www.typescriptlang.org/docs/handbook/basic-types.html#introduction">JS 的原始数据类型</a>。其中null和undefined类型见<a title="http://www.typescriptlang.org/docs/handbook/advanced-types.html#nullable-types" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#nullable-types">此处的详细说明</a></li>
<li>void、any（“类型系统你不要检查了！反正全是等价的”）、never（<a title="https://www.zhihu.com/question/354601204" href="https://www.zhihu.com/question/354601204">“反正这个值按理来说是不可能被 reach 的，就叫它 never 类型吧，并让它不与其它任何类型等价。如果该值被类型系统拿去比较了（必不匹配），说明逻辑有错”</a>）、<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type">unkonwn</a>（<a title="https://www.zhihu.com/question/355283769/answer/944821419" href="https://www.zhihu.com/question/355283769/answer/944821419">“我此时不清楚值的具体类型，但我在之后会看情况钦点（断言）一个。类型系统仍然要检查其合法性”</a>）</li>
<li><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol">unique symbol</a></li>
<li><a title="http://www.typescriptlang.org/docs/handbook/enums.html" href="http://www.typescriptlang.org/docs/handbook/enums.html">枚举</a>：用于（在编译期或运行时）定义带类型信息的常量 （常量值可自动获得/程序员手动指定） 。关键字<code>enum </code>
<ul>
<li>数字枚举、字符串枚举、混合枚举</li>
<li>constant member（symbol 在编译期即可得到值） 和  computed member（symbol 在运行时得到值）</li>
<li><code>const enum</code>：symbol 仅存在于编译期（因此不能包含 computed member）</li>
</ul>
</li>
<li>一些预置的 <a title="https://www.typescriptlang.org/docs/handbook/utility-types.html#introduction" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#introduction">utility types</a>（。让程序员进行类型操作，利用泛型机制得到新类型</li>
</ul>
</li>
<li>自定义类型
<ul>
<li><a title="https://basarat.gitbooks.io/typescript/content/docs/types/literal-types.html" href="https://basarat.gitbooks.io/typescript/content/docs/types/literal-types.html">literal types</a>：任一能在编译期得到值的字符串/数字/布尔值/对象/数组的字面量（表示一个值域有且仅有一个值的类型）</li>
<li><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types">Template Literal Types</a>：可以用模版字符串的语法生成 string literl types（<a title="https://www.zhihu.com/question/418792736" href="https://www.zhihu.com/question/418792736">用法示例</a>）</li>
<li><a title="http://www.typescriptlang.org/docs/handbook/basic-types.html#array" href="http://www.typescriptlang.org/docs/handbook/basic-types.html#array">typed array</a>、<a title="http://www.typescriptlang.org/docs/handbook/basic-types.html#tuple" href="http://www.typescriptlang.org/docs/handbook/basic-types.html#tuple">typed tuple</a>（支持<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#optional-elements-in-tuple-types" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#optional-elements-in-tuple-types">可选的成员</a>、<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#rest-elements-in-tuple-types" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#rest-elements-in-tuple-types">剩余成员</a>（<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#leadingmiddle-rest-elements-in-tuple-types" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#leadingmiddle-rest-elements-in-tuple-types">未必要在尾部</a>））。它们都可以<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#improvements-for-readonlyarray-and-readonly-tuples" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#improvements-for-readonlyarray-and-readonly-tuples">使用<code>readonly</code>修饰符</a>。typed tuple 还支持<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#labeled-tuple-elements" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#labeled-tuple-elements">为成员加 label</a></li>
<li>class</li>
<li>interface：描述数据应有结构（shape）。两种定义方式：使用<code>interface</code>关键字声明语法、<a title="http://www.typescriptlang.org/docs/handbook/interfaces.html#our-first-interface" href="http://www.typescriptlang.org/docs/handbook/interfaces.html#our-first-interface">使用  inline   语法</a>
<ul>
<li>对象的 shape：
<ul>
<li><a title="http://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks" href="http://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks">Excess Property Checks</a> （该约束只对对象字面量有效，即  <a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#stricter-object-literal-assignment-checks" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#stricter-object-literal-assignment-checks">strict object literal checking</a> ）</li>
<li><a title="http://www.typescriptlang.org/docs/handbook/interfaces.html#optional-properties" href="http://www.typescriptlang.org/docs/handbook/interfaces.html#optional-properties">可选属性 （<code>?:</code>） </a>（全是可选属性的接口是一个<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html#weak-type-detection" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html#weak-type-detection">weak type</a>。该种类型的属性不能被全部遗漏）</li>
<li><a title="http://www.typescriptlang.org/docs/handbook/interfaces.html#readonly-properties" href="http://www.typescriptlang.org/docs/handbook/interfaces.html#readonly-properties">只读属性 （<code>readOnly</code>）</a></li>
<li><a title="http://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types" href="http://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types">索引属性 （<code>[index:]</code>）</a>（ 用于约束属性名和属性值，其中属性名支持 number / string / symbol 类型。 可用于<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#implicit-index-signatures" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#implicit-index-signatures">规避 Excess Property Checks</a>。<code>index</code>可以换成任何你喜欢的字样）。一个 interface 中可有多个索引属性</li>
</ul>
</li>
<li><a title="http://www.typescriptlang.org/docs/handbook/interfaces.html#function-types" href="http://www.typescriptlang.org/docs/handbook/interfaces.html#function-types">函数的 shape</a>： 包括 <a title="https://basarat.gitbooks.io/typescript/content/docs/types/callable.html#newable" href="https://basarat.gitbooks.io/typescript/content/docs/types/callable.html#newable">newable 函数</a>、<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#abstract-construct-signatures" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#abstract-construct-signatures">抽象构造函数</a>。 支持约束<a title="https://basarat.gitbooks.io/typescript/content/docs/types/callable.html#obvious-examples" href="https://basarat.gitbooks.io/typescript/content/docs/types/callable.html#obvious-examples">可选参数、剩余参数</a>（其中剩余参数支持<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#spread-expressions-with-tuple-types" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#spread-expressions-with-tuple-types">使用 typed tuple 作类型</a>，并且<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types">tuple 中还可以有泛型</a> ）；支持<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#specifying-the-type-of-this-for-functions" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#specifying-the-type-of-this-for-functions">约束 <code>this</code></a></li>
<li><a title="http://www.typescriptlang.org/docs/handbook/interfaces.html#hybrid-types" href="http://www.typescriptlang.org/docs/handbook/interfaces.html#hybrid-types">混合的 shape</a>（用于约束一个可调用对象）</li>
<li>声明接口时，可以重复声明同一个接口，TS 会<a title="http://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces" href="http://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces">合并其中重复的规则</a></li>
</ul>
</li>
<li><a title="https://basarat.gitbooks.io/typescript/docs/types/functions.html#declaring-functions" href="https://basarat.gitbooks.io/typescript/docs/types/functions.html#declaring-functions">函数签名（callable类型）</a>：允许脱离具体的函数的声明或表达式来定义一个函数签名。通常用于为函数变量、高阶函数的（函数）参数等施加类型检查</li>
<li><a title="http://www.typescriptlang.org/docs/handbook/advanced-types.html#polymorphic-this-types" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#polymorphic-this-types">Polymorphic <code>this</code> types</a>： 用于一个父类方法，用关键字<code>this</code>表示其任意子类型</li>
<li>经类型运算得到的类型
<ul>
<li><a title="http://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types">Union types（<code>|</code>）</a>：多个类型取“或”关系。补充：
<ul>
<li>一个技巧是连接多个<a title="http://www.typescriptlang.org/docs/handbook/advanced-types.html#numeric-literal-types" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#numeric-literal-types">字符串字面量</a>或<a title="http://www.typescriptlang.org/docs/handbook/advanced-types.html#string-literal-types" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#string-literal-types">数字字面量</a>，组成一个可取值集合以作为一个类型</li>
<li>如果被连接的多个类型**都具有一个同名的成员，且在各类型中，满足：<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#non-unit-types-as-union-discriminants" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#non-unit-types-as-union-discriminants">未被指定为一个泛型类型，且至少在一个类型中被指定为 literal type**（各类型的该成员的类型不必都一样）</a>，则自动构成 <a title="http://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions">Discriminated Unions</a> （此时该成员称为 tag ） 。在使用 discriminated unions 时，TS 编译期会实施 <a title="http://www.typescriptlang.org/docs/handbook/advanced-types.html#exhaustiveness-checking" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#exhaustiveness-checking">Exhaustiveness checking</a>（这是一个 type gurad特性。见下文），以检查使用它的代码是否处理了所有的 type（<a title="https://basarat.gitbooks.io/typescript/content/docs/types/discriminated-unions.html#exhaustive-checks" href="https://basarat.gitbooks.io/typescript/content/docs/types/discriminated-unions.html#exhaustive-checks">示例</a>）。对于 tag，TS 会试图<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#smarter-union-type-checking" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#smarter-union-type-checking">将被连接的多个类型中的 tag 组成一个 union type</a></li>
</ul>
</li>
<li><a title="http://www.typescriptlang.org/docs/handbook/advanced-types.html#intersection-types" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#intersection-types">Intersection Types（<code>&amp;</code>）</a>：多个类型取“且”关系</li>
<li><a title="http://www.typescriptlang.org/docs/handbook/advanced-types.html#index-types" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#index-types">index type query operator（关键字<code>keyof</code>）</a>：常接一泛型类型参数。<code>keyof T</code> is the <strong>union</strong> of known, public property names(string、<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#support-number-and-symbol-named-properties-with-keyof-and-mapped-types" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#support-number-and-symbol-named-properties-with-keyof-and-mapped-types">number or symbol</a>) of <code>T</code>。对于 intersection type，有<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#improved-keyof-with-intersection-types" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#improved-keyof-with-intersection-types"><code> keyof (A &amp; B)</code>  等价于<code> keyof A | keyof B</code></a></li>
<li><a title="http://www.typescriptlang.org/docs/handbook/advanced-types.html#index-types" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#index-types">indexed access operator（<code>T[K]</code>，其中T是一个类型名，K是T的一个字段名）</a> ： 常接泛型类型参数。得到类型T的字段K的类型。实例：该<a title="https://zhuanlan.zhihu.com/p/39620591" href="https://zhuanlan.zhihu.com/p/39620591">文章</a>中”巧用查找类型“一节</li>
<li><a title="https://mariusschulz.com/blog/type-queries-and-typeof-in-typescript#typescripts-type-queries" href="https://mariusschulz.com/blog/type-queries-and-typeof-in-typescript#typescripts-type-queries">type query（关键字<code>typeof</code>）</a>： A type query obtains the type of an   identifier   or   property access expression   (that is, multiple identifiers connected by dots)</li>
<li><a title="http://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types">mapped types（关键字<code>in</code>）</a>：根据一个已有的类型（可以且通常是泛型）映射得到一个新类型。可映射名字的类型为string、<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#support-number-and-symbol-named-properties-with-keyof-and-mapped-types" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#support-number-and-symbol-named-properties-with-keyof-and-mapped-types">number 或 symbol 类型</a> 的属性。对于 typed array 和 typed tuple，<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html#mapped-types-on-tuples-and-arrays" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html#mapped-types-on-tuples-and-arrays">只能映射它们的数字属性</a>。做映射时可以使用<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#improved-control-over-mapped-type-modifiers" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#improved-control-over-mapped-type-modifiers"><code>+</code>和<code>-</code>为映射后的类型上的成员添加/去除修饰符</a>（例如<code>readonly</code>、<code>?</code>等），其中<code>readonly</code>也<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#readonly-mapped-type-modifiers-and-readonly-arrays" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#readonly-mapped-type-modifiers-and-readonly-arrays">能在给 typed array 和 typed couple 做映射时使用</a>。映射时，<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types">可以使用<code>as</code>关键字将欲映射的类型先映射一次</a>（也就是说，总的来说你可以映射两次）</li>
<li><a title="http://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types">conditional types</a>：用来表述非单一形式的类型。A conditional type selects one of two possible types（<code>X</code>、<code>Y</code>） based on a condition expressed as a type relationship test（形如<code>T extends U ? X : Y</code>）, either resolved to <code>X</code> or <code> Y</code>, or   deferred until  type system has enough information to conclude  that <code> T</code>  is always assignable to <code> U</code>。一个具体例子可见<a title="https://zhuanlan.zhihu.com/p/64446259" href="https://zhuanlan.zhihu.com/p/64446259">这篇文章</a>中的“条件类型”一节
<ul>
<li>如果<code>T</code>是个 Union Type，则<a title="http://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types">会被展开（ distributed   ）</a></li>
<li><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#type-inference-in-conditional-types" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#type-inference-in-conditional-types"><code>infer</code> keyword</a> says to TypeScript: “<a title="https://dev.to/miracleblue/how-2-typescript-serious-business-with-typescripts-infer-keyword-40i5" href="https://dev.to/miracleblue/how-2-typescript-serious-business-with-typescripts-infer-keyword-40i5">I want to take whatever TypeScript infers to be at this position and assign it to a name</a>”。仅能用于<code>extends</code>子句中</li>
<li><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types">支持递归</a></li>
</ul>
</li>
</ul>
</li>
<li>由<a title="http://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases">type alias（关键字<code>type</code>）</a>定义的类型。该功能用于为类型取别名（尤其是经类型运算得来的类型）。别名不能用来 implement 或 extends。<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#more-recursive-type-aliases" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#more-recursive-type-aliases">可以递归定义</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p>class, interface, enum, 和 type alias 的作用域<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#local-type-declarations" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#local-type-declarations">最小可以是块级</a></p>
</li>
<li>
<p>类型之间有兼容关系。兼容的两个类型不受类型约束的限制。TS 大体上采用的是”结构等价“的类型兼容性判断策略</p>
<ul>
<li><a title="http://www.typescriptlang.org/docs/handbook/type-compatibility.html#starting-out" href="http://www.typescriptlang.org/docs/handbook/type-compatibility.html#starting-out">接口间的兼容</a>： The basic rule for TypeScript’s structural type system is that   x   is compatible with  <code> y</code>   if  <code> y</code>   has at least the same members as  <code> x</code>。若想采用”名字等价“的类型兼容性判断策略，workaround 见<a title="https://basarat.gitbooks.io/typescript/content/docs/tips/nominalTyping.html" href="https://basarat.gitbooks.io/typescript/content/docs/tips/nominalTyping.html">此处</a></li>
<li><a title="http://www.typescriptlang.org/docs/handbook/type-compatibility.html#comparing-two-functions" href="http://www.typescriptlang.org/docs/handbook/type-compatibility.html#comparing-two-functions">函数类型之间的兼容</a></li>
<li><a title="http://www.typescriptlang.org/docs/handbook/type-compatibility.html#enums" href="http://www.typescriptlang.org/docs/handbook/type-compatibility.html#enums">枚举与Number之间的兼容</a></li>
<li><a title="http://www.typescriptlang.org/docs/handbook/type-compatibility.html#classes" href="http://www.typescriptlang.org/docs/handbook/type-compatibility.html#classes">无继承关系的类与类之间的兼容</a></li>
<li><a title="http://www.typescriptlang.org/docs/handbook/type-compatibility.html#generics" href="http://www.typescriptlang.org/docs/handbook/type-compatibility.html#generics">使用了泛型时的兼容规则</a></li>
<li><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#fixed-length-tuples" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#fixed-length-tuples">tuple 类型与 tuple 类型之间的兼容</a></li>
<li>存在 subtype 或 extends 关系的类型之间</li>
</ul>
</li>
<li>
<p>程序员钦点类型的方法</p>
<ul>
<li>
<p><a title="http://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions" href="http://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions"><strong>类型断言</strong>（<code>as</code>）</a>，允许程序员指定编译器在编译期将任何值（可以是变量或者字面量）钦点为某个指定类型，以覆盖 TS 类型推断的得到的类型或此前程序员指定的类型（<em>一旦这么做，类型安全就需要由程序员自己加以保证了</em>）。<em>该功能不是在运行时发生的 type casting</em>。 Basically, the assertion from type   S   to   T   succeeds if either   S   is a subtype of   T   or   T   is a subtype of   S。亦可凭空（即不基于 subtype 关系）进行类型断言，但不建议这么做。类型断言的其它形式包括：</p>
<ul>
<li><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator">Non-null assertion operator（<code>!</code>）</a>：它断言其左边的值不会是 null 或 undefined</li>
<li><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#definite-assignment-assertions" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#definite-assignment-assertions">Definite Assignment Assertions（<code>!</code>）</a>：对一个变量使用，可以告诉 TypeScript 它的值的类型一定不会是    null 或 undefined</li>
<li>对字面量值可使用<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions"><code>as const</code>进行断言</a>，断言为一个 literal type。对对象字面量，其上所有成员 readonly；对数组字面量，断言得到 readonly tuple</li>
</ul>
</li>
<li>
<p><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#control-flow-based-type-analysis" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#control-flow-based-type-analysis">利用控制流来收窄类型</a>（比类型断言更灵活）</p>
<ul>
<li>
<p><a title="http://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards">type predicate（<code>is</code>）</a>：利用  user-defined type guards function  进行类型保证，支持对<code>this</code>使用（即<code>this is ...</code>）。 TS 编译器把该类函数被调用且返回值为 true 的代码块内，被传给该类函数的变量的类型一律视为<code>is</code>指定的结果。该语言特性可用来消除一段代码内反复出现的对同一类型的断言</p>
</li>
<li>
<p><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions">assert function</a>：利用  assert function 进行类型保证。 TS 编译器把位于该类函数被调用的位置之后，被传给该类函数的变量的类型视为<code>assert...is</code>指定的结果；或是把作为 a sserts condition 的表达式（使用了 J S 运算符<code>typeof</code>/<code>instanceof</code>/<code>in</code> ）中得到的类型信息作为随后的类型。该功能是个升级版的 type predicate</p>
</li>
<li>
<p><a title="https://basarat.gitbooks.io/typescript/content/docs/types/typeGuard.html" href="https://basarat.gitbooks.io/typescript/content/docs/types/typeGuard.html">type guard</a>，基于控制流中某些语句——例如搭配了 type narrowing（指“ 对 assert function 的调用、使用  JS 运算符<code>typeof</code>/<code>instanceof</code>/<code>in</code>或使用了  Discriminated Unions 中的 tag（见上文）以及 type predicate的情况） 的   <code>if...else</code>、<code>return</code>、<code>break</code>语句以及使用了<code>?:</code>运算符的表达式语句，自动推断出类型</p>
<ul>
<li>支持 <a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-and-non-undefined-type-guards" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-and-non-undefined-type-guards">non-null check</a></li>
<li>支持 [dotted names checking](<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#dotted-names-in-type-guards" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#dotted-names-in-type-guards">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#dotted-names-in-type-guards</a></li>
</ul>
</li>
<li>
<p><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#destructured-variables-can-be-explicitly-marked-as-unused" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#destructured-variables-can-be-explicitly-marked-as-unused">在解构时显式标明无用变量</a>，避免 noUnused 报错</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>TS 支持<a title="http://www.typescriptlang.org/docs/handbook/type-inference.html" href="http://www.typescriptlang.org/docs/handbook/type-inference.html"><strong>类型推断</strong></a>，在程序员没有手动指定类型的地方，编译器尽量根据上下文类型自动指定一个类型以用于静态类型检查（注意：必须熟悉 TS 的类型推断规则。由 TS 自动推断出的、并用于实施约束的类型很可能和程序员的预料不一样。别无他法时，可使用类型断言来覆盖类型推断的结果）</p>
<ul>
<li>
<p><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#improved-checking-for-destructuring-object-literal" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#improved-checking-for-destructuring-object-literal">对使用了解构赋值的变量的推断规则</a></p>
</li>
<li>
<p><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#improved-checking-for-forin-statements" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#improved-checking-for-forin-statements">对 for…in 语句中的变量的推断规则</a></p>
</li>
<li>
<p><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html#improved-inference-for-generics" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html#improved-inference-for-generics">对使用了泛型的类型的推断规则</a></p>
</li>
<li>
<p><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#expression-operators" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#expression-operators">对使用了逻辑运算符的表达式的推断规则</a></p>
</li>
<li>
<p><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#improved-type-inference-for-object-literals" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#improved-type-inference-for-object-literals">对使用对象字面量赋值的变量的推断规则</a>以及<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#generic-spread-expressions-in-object-literals" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#generic-spread-expressions-in-object-literals">使用对象展开操作符时的推断规则</a></p>
</li>
<li>
<p><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-3.html#improved-behavior-for-calling-union-types" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-3.html#improved-behavior-for-calling-union-types">对 callable 类型的 union 的调用得到的值的类型的推断规则</a></p>
</li>
<li>
<p><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#higher-order-type-inference-from-generic-functions" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#higher-order-type-inference-from-generic-functions">对一个由使用了泛型类型的参数的<em>高阶函数</em>返回的函数的类型推断规则</a></p>
</li>
<li>
<p>有的情况下能<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#better-inference-for-literal-types" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#better-inference-for-literal-types">推断得到 literal types</a></p>
</li>
<li>
<p><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#higher-order-type-inference-from-generic-constructors" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#higher-order-type-inference-from-generic-constructors">Higher order type inference from generic constructors</a></p>
</li>
<li>
<p><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#improved-any-inference" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#improved-any-inference">尽可能不推断出 any</a></p>
</li>
</ul>
</li>
<li>
<p>TS 支持在<a title="http://www.typescriptlang.org/docs/handbook/generics.html#generic-types" href="http://www.typescriptlang.org/docs/handbook/generics.html#generic-types">函数、接口</a>以及<a title="http://www.typescriptlang.org/docs/handbook/generics.html#generic-classes" href="http://www.typescriptlang.org/docs/handbook/generics.html#generic-classes">类</a>（包括 <a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#generic-type-arguments-in-jsx-elements" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#generic-type-arguments-in-jsx-elements">JSX 表示的元素字面量</a>）上使用<strong>泛型类型</strong> （其中对函数允许用泛型类型<a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#generic-rest-parameters" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#generic-rest-parameters">约束剩余参数</a>） 。泛型类型是参数化的类型。被使用泛型类型所约束的东西在使用时可以为类型参数指定具体类型（即显式指定泛型参数），否则将依赖 TS 的类型推导确定类型参数的具体类型</p>
<ul>
<li>支持多个类型参数，<a title="http://www.typescriptlang.org/docs/handbook/generics.html#using-type-parameters-in-generic-constraints" href="http://www.typescriptlang.org/docs/handbook/generics.html#using-type-parameters-in-generic-constraints">它们之间可以构成约束关系</a></li>
<li>可<a title="http://www.typescriptlang.org/docs/handbook/generics.html#generic-constraints" href="http://www.typescriptlang.org/docs/handbook/generics.html#generic-constraints">令类型参数与类或接口构成约束（使用<code>extends</code>关键字）</a>。可以 <a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#type-parameters-that-extend-any-no-longer-act-as-any" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#type-parameters-that-extend-any-no-longer-act-as-any">extends any 类型</a></li>
<li><a title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html#generic-parameter-defaults" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html#generic-parameter-defaults">类型参数可以有默认值</a>。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用</li>
<li><a title="http://www.typescriptlang.org/docs/handbook/generics.html#using-class-types-in-generics" href="http://www.typescriptlang.org/docs/handbook/generics.html#using-class-types-in-generics">如何对工厂函数应用泛型</a></li>
</ul>
</li>
</ul>
<h1 id="其它">其它</h1>
<ul>
<li>.d.ts 文件</li>
<li><a title="http://www.typescriptlang.org/docs/handbook/module-resolution.html" href="http://www.typescriptlang.org/docs/handbook/module-resolution.html">模块路径确定策略</a></li>
</ul>
</div>
      </article>
    </div>
  </body>
</html>
